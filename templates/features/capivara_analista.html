{% extends 'base.html' %}

{% block title %}Capivara Analista{% endblock %}

{% block custom_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/chat_styles.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/image_upload_button.css') }}">
{# Remove capivara_analista.css to avoid style conflicts #}
{% endblock %}

{% block content %}
<div class="chat-container" role="main" aria-label="Chat Capivara Analista">
    <header class="chat-header">
        <div class="header-left">
            <div class="ai-avatar" aria-hidden="true">
                <i class="fas fa-hippo"></i>
            </div>
            <div class="header-info">
                <h1>Capivara Analista</h1>
                <div class="status" aria-live="polite" aria-atomic="true">
                    <div class="status-dot"></div>
                    <span>Online</span>
                </div>
            </div>
        </div>
        <div class="user-menu">
            <a href="{{ url_for('main.home') }}" class="btn btn-primary btn-voltar" aria-label="Voltar para a home">
                Voltar
            </a>
        </div>
    </header>

    <main class="messages-container" aria-live="polite" aria-relevant="additions">
        <div class="empty-state" role="region" aria-label="Empty chat state">
            <div class="empty-state-icon" aria-hidden="true">
                <i class="fas fa-comments"></i>
            </div>
            <h3>Inicie uma conversa</h3>
            <p>Pergunte à Capivara Analista</p>
            <div class="suggestions" role="list">
                <div class="suggestion" role="listitem" tabindex="0" onclick="sendSuggestion('Como você pode me ajudar?')">Como você pode me ajudar?</div>
                <div class="suggestion" role="listitem" tabindex="0" onclick="sendSuggestion('Como identificar meu Arquétipo?')">Como identificar meu Arquétipo?</div>
                <div class="suggestion" role="listitem" tabindex="0" onclick="sendSuggestion('Como melhorar o engajamento?')">Como melhorar o engajamento?</div>
                <div class="suggestion" role="listitem" tabindex="0" onclick="sendSuggestion('Quero uma análise brutal!')">Quero uma análise brutal!</div>
            </div>
        </div>

        <div class="typing-indicator" aria-live="polite" aria-atomic="true" aria-label="AI is typing" style="display:none;">
            <div class="message-avatar" aria-hidden="true">
                <i class="fas fa-hippo"></i>
            </div>
            <div class="typing-dots" aria-hidden="true">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            </div>
            <span style="color: var(--text-muted); font-size: 0.875rem;">Capivara Analista está digitando...</span>
        </div>
    </main>

    <div class="input-container">
        <form class="input-form" id="chatForm" aria-label="Send a message" method="post" action="{{ url_for('main.capivara_analista_chat') }}">
            <div class="input-wrapper">
                <textarea 
                    id="messageInput" 
                    name="message" 
                    class="message-input" 
                    placeholder="Digite sua mensagem aqui..." 
                    aria-required="true"
                    rows="1"
                    autocomplete="off"
                    spellcheck="false"
                ></textarea>
                <div class="input-actions">
                    <input type="file" id="imageInput" accept="image/png, image/jpeg" aria-label="Upload image" style="display:none;">
                    <button type="button" id="imageUploadButton" class="image-upload-button" aria-label="Upload image">
                        <i class="fas fa-image"></i>
                    </button>
                    <button type="submit" class="send-button" id="sendButton" aria-label="Send message" disabled>
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </form>
    </div>
</div>

<script>
function formatTimestamp(date) {
    const optionsTime = { hour: '2-digit', minute: '2-digit', timeZone: 'America/Sao_Paulo' };
    const dt = new Date(date.toLocaleString("en-US", {timeZone: "America/Sao_Paulo"}));
    return dt.toLocaleTimeString('pt-BR', optionsTime);
}

function updateAllTimestamps() {
    const timestampElements = document.querySelectorAll('.message-timestamp[data-timestamp]');
    timestampElements.forEach(el => {
        const ts = el.getAttribute('data-timestamp');
        if (ts) {
            const date = new Date(ts);
            if (!isNaN(date)) {
                el.textContent = formatTimestamp(date);
            }
        }
    });
}

class ChatInterface {
    constructor() {
        this.messagesContainer = document.querySelector('.messages-container');
        this.messageInput = document.getElementById('messageInput');
        this.chatForm = document.getElementById('chatForm');
        this.sendButton = document.getElementById('sendButton');
        this.typingIndicator = document.querySelector('.typing-indicator');
        this.emptyState = document.querySelector('.empty-state');
        this.imageInput = document.getElementById('imageInput');
        this.imageUploadButton = document.getElementById('imageUploadButton');

        this.init();
    }

    init() {
        this.setupEventListeners();
        this.setupTextareaAutoResize();
        this.scrollToBottomOnLoad();
        updateAllTimestamps();
    }

    setupEventListeners() {
        this.chatForm.addEventListener('submit', (e) => this.handleSubmit(e));
        this.messageInput.addEventListener('keydown', (e) => this.handleKeyDown(e));
        this.messageInput.addEventListener('input', () => this.updateSendButton());
        this.imageUploadButton.addEventListener('click', () => this.imageInput.click());
        this.imageInput.addEventListener('change', (e) => this.handleImageUpload(e));
    }

    setupTextareaAutoResize() {
        this.messageInput.addEventListener('input', () => {
            this.messageInput.style.height = 'auto';
            this.messageInput.style.height = Math.min(this.messageInput.scrollHeight, 120) + 'px';
        });
    }

    scrollToBottomOnLoad() {
        // Scroll to the bottom when the page loads
        requestAnimationFrame(() => {
            this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
        });
    }

    handleKeyDown(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            this.handleSubmit(e);
        }
    }

    handleSubmit(e) {
        e.preventDefault();
        const message = this.messageInput.value.trim();
        if (!message) return;

        this.sendMessage(message);
    }

    updateSendButton() {
        const hasText = this.messageInput.value.trim().length > 0;
        this.sendButton.disabled = !hasText;
    }

    async sendMessage(messageText, messageType = 'text') {
        // Hide empty state
        if (this.emptyState) {
            this.emptyState.style.display = 'none';
        }

        // Add user message
        this.addMessage(messageText, 'user');
        
        // Clear input
        this.messageInput.value = '';
        this.messageInput.style.height = 'auto';
        this.updateSendButton();

        // Show typing indicator
        this.showTypingIndicator();

        // Helper function to delay execution
        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        try {
            // Send message to backend API
            const payload = {
                message: messageText,
                type: messageType
            };
            const response = await fetch('{{ url_for("main.capivara_analista_chat") }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            if (data.error) {
                throw new Error(data.error);
            }

            // Split assistant response by sentence and add each as a separate message with delay
            if (typeof data.response === 'string') {
                const sentences = this.splitIntoMessages(data.response);
                for (const sentence of sentences) {
                    this.addMessage(sentence, 'assistant');
                    await delay(5000); // wait 3 seconds before next message
                }
            } else {
                // If not string, add as is
                this.addMessage(data.response, 'assistant');
            }
        } catch (error) {
            console.error('Chat error:', error);
            this.addMessage('Sorry, I encountered an error. Please try again.', 'assistant', true);
        } finally {
            this.hideTypingIndicator();
        }
    }

    splitIntoMessages(text) {
        const sentences = [];
        let currentSentence = '';
        
        // Split by numbered points (e.g., "1.", "2.", etc.) to ensure they start new messages
        const parts = text.split(/(\d+\.\s*)/);
        
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            
            // If this part is a numbered point (e.g., "1. ")
            if (/^\d+\.\s*$/.test(part)) {
                // If we have accumulated content, save it as a sentence (with minimum 3 chars)
                if (currentSentence.trim().length >= 3) {
                    sentences.push(currentSentence.trim());
                }
                // Start new sentence with the numbered point
                currentSentence = part;
            } else {
                // Add this part to current sentence
                currentSentence += part;
                
                // Check for sentence endings (., !, ?)
                const sentenceEndings = currentSentence.match(/[.!?]+/g);
                if (sentenceEndings) {
                    // Split by sentence endings but keep the endings
                    const subSentences = currentSentence.split(/([.!?]+)/);
                    let tempSentence = '';
                    
                    for (let j = 0; j < subSentences.length; j++) {
                        const subPart = subSentences[j];
                        tempSentence += subPart;
                        
                        // If this is a sentence ending and we have enough content
                        if (/^[.!?]+$/.test(subPart) && tempSentence.trim().length >= 3) {
                            sentences.push(tempSentence.trim());
                            tempSentence = '';
                        }
                    }
                    
                    // Keep any remaining content for next iteration
                    currentSentence = tempSentence;
                }
            }
        }
        
        // Add any remaining content if it meets minimum length
        if (currentSentence.trim().length >= 3) {
            sentences.push(currentSentence.trim());
        }
        
        // Filter out empty or too short sentences
        return sentences.filter(sentence => sentence.trim().length >= 3);
    }

    addMessage(content, role, isError = false) {
        const messageElement = document.createElement('div');
        messageElement.className = `message ${role}`;

        // Check if content is a base64 image data URI
        const isImage = typeof content === 'string' && content.startsWith('data:image/');

        let messageContentHtml = '';
        if (isImage) {
            messageContentHtml = `<img src="${content}" alt="User uploaded image" class="message-image-thumbnail" />`;
        } else {
            // Format AI assistant response for user-friendly display with basic markdown parsing
            if (role === 'assistant' && typeof content === 'string') {
                // Escape HTML special characters
                const escapeHtml = (unsafe) => {
                    return unsafe.replace(/[&<>"']/g, function(m) {
                        switch (m) {
                            case '&': return '&amp;';
                            case '<': return '<';
                            case '>': return '>';
                            case '"': return '"';
                            case "'": return '&#039;';
                            default: return m;
                        }
                    });
                };

                // Basic markdown to HTML conversion
                const markdownToHtml = (text) => {
                    let html = escapeHtml(text);

                    // Convert headers (e.g., ### Header)
                    html = html.replace(/^### (.*)$/gm, '<h3>$1</h3>');
                    html = html.replace(/^## (.*)$/gm, '<h2>$1</h2>');
                    html = html.replace(/^# (.*)$/gm, '<h1>$1</h1>');

                    // Convert bold **text** or __text__
                    html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    html = html.replace(/__(.*?)__/g, '<strong>$1</strong>');

                    // Convert italics *text* or _text_
                    html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
                    html = html.replace(/_(.*?)_/g, '<em>$1</em>');

                    // Convert unordered lists
                    html = html.replace(/^\s*[-*+] (.*)$/gm, '<li>$1</li>');
                    html = html.replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>');

                    // Convert line breaks
                    html = html.replace(/\n/g, '<br>');

                    return html;
                };

                messageContentHtml = markdownToHtml(content);
            } else {
                messageContentHtml = content;
            }
        }

        messageElement.innerHTML = `
            <div class="message-avatar">
                ${role === 'user' ? '<i class="fas fa-user"></i>' : '<i class="fas fa-hippo"></i>'}
            </div>
            <div class="message-content-wrapper">
                <div class="message-bubble ${isError ? 'error' : ''}">
                    ${messageContentHtml}
                    <div class="message-timestamp" style="text-align: right; font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem;">
                        ${formatTimestamp(new Date())}
                    </div>
                </div>
            </div>
        `;

        // Insert before typing indicator if it exists
        const typingIndicator = this.messagesContainer.querySelector('.typing-indicator');
        if (typingIndicator) {
            this.messagesContainer.insertBefore(messageElement, typingIndicator);
        } else {
            this.messagesContainer.appendChild(messageElement);
        }

        this.scrollToBottom();
    }

    showTypingIndicator() {
        this.typingIndicator.style.display = 'flex';
        this.scrollToBottom();
    }

    hideTypingIndicator() {
        this.typingIndicator.style.display = 'none';
    }

    scrollToBottom() {
        requestAnimationFrame(() => {
            this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
        });
    }

    handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const allowedTypes = ['image/jpeg', 'image/png', 'image/jpg'];
        if (!allowedTypes.includes(file.type)) {
            alert('Apenas arquivos de imagem PNG ou JPEG são permitidos.');
            return;
        }

        const maxSizeMB = 5;
        if (file.size > maxSizeMB * 1024 * 1024) {
            alert(`O arquivo excede o tamanho máximo de ${maxSizeMB}MB.`);
            return;
        }

        const reader = new FileReader();
        reader.onload = () => {
            const base64Data = reader.result;
            this.sendMessage(base64Data, 'image');
        };
        reader.readAsDataURL(file);

        // Reset the input so the same file can be uploaded again if needed
        this.imageInput.value = '';
    }
}

// Global function for suggestion clicks
function sendSuggestion(text) {
    const chat = new ChatInterface();
    chat.messageInput.value = text;
    chat.sendMessage(text);
}

// Initialize chat when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new ChatInterface();
});
</script>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
    // Override addMessage to use marked.js for assistant messages
    const originalAddMessage = ChatInterface.prototype.addMessage;
    ChatInterface.prototype.addMessage = function(content, role, isError = false) {
        const messageElement = document.createElement('div');
        messageElement.className = `message ${role}`;

        // Check if content is a base64 image data URI
        const isImage = typeof content === 'string' && content.startsWith('data:image/');

        let messageContentHtml = '';
        if (isImage) {
            messageContentHtml = `<img src="${content}" alt="User uploaded image" class="message-image-thumbnail" />`;
        } else {
            if (role === 'assistant' && typeof content === 'string') {
                // Use marked.js to parse markdown safely
                messageContentHtml = marked.parse(content);
            } else {
                messageContentHtml = content;
            }
        }

        messageElement.innerHTML = `
            <div class="message-avatar">
                ${role === 'user' ? '<i class="fas fa-user"></i>' : '<i class="fas fa-hippo"></i>'}
            </div>
            <div class="message-content-wrapper">
                <div class="message-bubble ${isError ? 'error' : ''}">
                    ${messageContentHtml}
                </div>
                <div class="message-timestamp">
                    ${formatTimestamp(new Date())}
                </div>
            </div>
        `;

        // Insert before typing indicator if it exists
        const typingIndicator = this.messagesContainer.querySelector('.typing-indicator');
        if (typingIndicator) {
            this.messagesContainer.insertBefore(messageElement, typingIndicator);
        } else {
            this.messagesContainer.appendChild(messageElement);
        }

        this.scrollToBottom();
    };
</script>

{% endblock %}
</body>
</html>
